---
title: "Analyze Tone Perception (1 syllable)"
author: Xiao Xiao
output: html_notebook
---
### Goals
This study aims to examine the range of variation in acceptable pronunciation of Mandarin tones. 

* Identify perceptual boundaries between tones
  * Determine the range of variation between native listeners
  * Compare the range of variation between types of syllables with the variation from individual listeners
* Create a model to predict the probabilities of a stimulus being identified as each tone  

### Procedure
6 native speakers of Mandarin listened to single syllables with varying frequency shifts and were shown 4 words with the same phoneme as the stimulus that varied only in tone. Subjects indicated which word, if any, they heard. Each stimulus could be heard up to two times. Syllables were synthesized using samples of a native female speaker from Beijing. The range of the speaker's voice was divided into 7 points, equally spaced on a semitone scale. 10 carrier syllables were used (e.g. */ma*, */yi*). For each carrier syllable, 49 stimuli were generated by linearly varying the fundamental frequency between every combination of start and end points. The evaluation was done from a webpage and consisted of 10 sections. Each section presented the 49 synthesized stimuli for a single carrier syllable in random order. To prevent fatigue, subjects were able to stop the test after each section and return to it at a later time.

### Analysis
Load the data and look at it. Start and end frequencies (*start.freq*, *end.freq*) are coded on a semitone scale from -6 to 6. This emcompasses the usual range of the speaker's voice. *freq.shift* is the amount of change betwewen *start.freq* and *end.freq*. For example -12 is down by 12 semitones.

Tones are referred to as T1, T2, T3, T4. Note that T3 is selected far less frequently than the others. This is not surprising because none of the stimuli have the "V" shape typical of T3 in isolation. A follow-up study is probably necessary to investigate the boundaries of for the V-shaped T3.

T1, T2, and T4 have pretty even proportions of selection. 
```{r}
library("tidyverse") #alwways
source("../utils/dataWrangling.R") #helper functions to load data

subjects <- c("s29", "s30", "s31", "s32", "s33", "s34")
master <- get_results(subjects, "../data/singleSyllableVariedTonePerception/")

summary(master)

```

Plotting all results all together. Each point represents the choice of tone for one stimuli by one subject. The points in each square all have the same start.freq and end.freq. The jitter makes it such that the points are not on top of each other. 

TN is "none of the above". T2 is the rising tone and occupies top left region (end.freq > start.freq). Tone 4 falls and occupies the bottom right region (end.freq < start.freq). T1 is normally described as "high steady." We would expect to find it along the diagonal on the top right corner, and we do. On the upper right corner, tone movements up to 2 semitones in either direction still get perceived as tone 1. Without the contrast from adjacent utterances, low steady tones also get perceived as tone 1. "None of the above" can be found along perceptual boundaries, with some clusters in the lower left corner.

```{r}

# Custome palette that assigns a specific color to each tone
palette <- c(
  "T1" = "skyblue",
  "T2" = "lightcoral", 
  "T3" = "forestgreen", 
  "T4" = "gold3",
  "TN" = "ivory" 
)

ggplot(master)+ geom_jitter(size=0.7, width = 0.5, height = 0.5,
                                  mapping = aes(x=start.freq, y=end.freq, color=selected_tone)) +
  xlab("Start frequency (ST)") + ylab("End Frequency (ST)") +
    scale_x_continuous(breaks = seq(-6, 6, by = 2)) +
    scale_y_continuous(breaks = seq(-6, 6, by = 2)) +
scale_color_manual(values = palette, limits = names(palette)) +
ggtitle("Jitter plot of all results")  
```

Looking at the choices from two subjects for two different carrier syllables. We see an example of the variation across subjects and across syllable.

```{r}
library("gridExtra")

# Function that filters the results of one subject for one carrier syllable
# and plots it in a grid
plot_one_group <- function(data, my_subject, my_syllable) {
  d <- filter(data, subject == my_subject & carrier_syllable == my_syllable)
       
  ggplot(d) +
    xlab("Start frequency (ST)") + ylab("End Frequency (ST)") +
    scale_x_continuous(breaks = seq(-6, 6, by = 2)) +
    scale_y_continuous(breaks = seq(-6, 6, by = 2)) +
    geom_label(aes(x=start.freq, y=end.freq, color=selected_tone, label=selected_tone), show.legend = FALSE) +
    scale_color_manual(values = palette,
                       limits = names(palette)) +
    labs(title = paste("Subject: ", my_subject, ", Syllable: ", my_syllable, sep="")) +
    theme(axis.text.x = element_text(color = "grey20", size = 6),
        axis.text.y = element_text(color = "grey20", size = 6),  
        axis.title.x = element_text(color = "grey20", size = 8),
        axis.title.y = element_text(color = "grey20", size = 8))
}

ma29 <- plot_one_group(master, "s29", "ma")
mao29 <- plot_one_group(master, "s29", "mao")

ma32 <- plot_one_group(master, "s32", "ma")
mao32 <- plot_one_group(master, "s32", "mao")

grid.arrange(ma29, mao29, ma32, mao32, nrow=2)
```

## Fitting Some Models

Theoretically, we can do a multinomial, multilevel logistic regression, but the results of multinomial logistic regressions are difficult to interpret. Also, multilevel logistic regressions work best when the number of results in each category are more or less even. This data has too few results in T3 and TN. 

### Intercept-only models

First we will look at a binomial logistic regression on Tone 2. Start with at intercept-only models and the random effect due to subject, syllable, and both. Looks like the intercept doesn't so much when random effects are accounted for.

#### Tone 2 vs Not Tone 2
```{r}
library(lme4)
library(jtools)

# intercept only models
model_intercept <- function(my_data) {
  glm(is.tone ~ 1, data = my_data, family = "binomial")
}

model_intercept_subject <- function(my_data) {
  glmer(is.tone ~ 1 + (1|subject), data = my_data, family = "binomial", nAGQ = 0)
}

model_intercept_syllable <- function(my_data) {
  glmer(is.tone ~ 1 + (1|carrier_syllable), data = my_data, family = "binomial", nAGQ = 0)
}

model_intercept_syllable_subject <- function(my_data) {
  glmer(is.tone ~ 1 + (1|carrier_syllable) + (1|subject), data = my_data, family = "binomial", nAGQ = 0)
}

# New column that is binary measure for the tone in question
dt2 <- data_for_selected_tone(master, "T2")

m2.0 <- model_intercept(dt2)
m2.1 <- model_intercept_subject(dt2)
m2.2 <- model_intercept_syllable(dt2)
m2.3 <- model_intercept_syllable_subject(dt2)

names <- c("Intercept only",
           "Random levels for subject",
           "Random levels for syllable",
           "Random levels for subject & syllable")
plot_coefs(m2.0, m2.1, m2.2, m2.3, model.names=names, omit.coefs=NULL)

```

#### Tone 4 vs Not Tone 4

```{r}

# New column that is binary measure for the tone in question
dt4 <- data_for_selected_tone(master, "T4")
  
m4.0 <- model_intercept(dt4)
m4.1 <- model_intercept_subject(dt4)
m4.2 <- model_intercept_syllable(dt4)
m4.3 <- model_intercept_syllable_subject(dt4)

plot_coefs(m4.0, m4.1, m4.2, m4.3, model.names=names, omit.coefs=NULL)

```

#### Tone 1 vs Not Tone 1

For tone 1 there seems to be a little bit of change if we have random levels in the model. 

```{r}
# New column that is binary measure for the tone in question
dt1 <- data_for_selected_tone(master, "T1")

m1.0 <- model_intercept(dt1)
m1.1 <- model_intercept_subject(dt1)
m1.2 <- model_intercept_syllable(dt1)
m1.3 <- model_intercept_syllable_subject(dt1)

plot_coefs(m1.0, m1.1, m1.2, m1.3, model.names=names, omit.coefs=NULL)
```

#### Tone 3 vs Not Tone 3
Since there are so few results in the Tone 3 category, these results probably don't mean much. I'm showing it just to show that I tried it. For tone 3, the intercept if quite different in models with random effects due to subject. This is consistent with the feedback from subjects. Because there were no v-shaped stimuli, some subjects never chose tone 3.

```{r}
# New column that is binary measure for the tone in question
dt3 <- data_for_selected_tone(master, "T3")

m3.0 <- model_intercept(dt3)
m3.1 <- model_intercept_subject(dt3)
m3.2 <- model_intercept_syllable(dt3)
m3.3 <- model_intercept_syllable_subject(dt3)

plot_coefs(m3.0, m3.1, m3.2, m3.3, model.names=names, omit.coefs=NULL)
```

### Adding some predictors

First, define the models. I started with the model where we are looking at the interraction between start.freq and freq.shift. Also defined a model where the two are independent.
```{r}
library("ggeffects")

model_predictors <- function(my_data) {
  glm(is.tone ~ start.freq * freq.shift, data = my_data, family = "binomial")
}

model_predictors_independent <- function(my_data) {
  glm(is.tone ~ start.freq + freq.shift, data = my_data, family = "binomial")
}

model_predictors_subject <- function(my_data) {
  glmer(is.tone ~ start.freq*freq.shift + (1|subject), data = my_data, family="binomial")
}

model_predictors_syllable <- function(my_data) {
  glmer(is.tone ~ start.freq*freq.shift + (1|carrier_syllable), data = my_data, family="binomial")
}

model_predictors_subject_syllable <- function(my_data) {
  glmer(is.tone ~ start.freq*freq.shift + (1|carrier_syllable) + (1|subject), data = my_data, family="binomial", nAGQ = 0)
}
```

#### Tone 2 vs Not Tone 2

```{r}
# For tone 2
m2.p.0 <- model_predictors(dt2)
m2.p.1 <- model_predictors_subject(dt2)
m2.p.2 <- model_predictors_syllable(dt2)
m2.p.3 <- model_predictors_subject_syllable(dt2)
names <- c("Intercept only",
           "Random levels for subject",
           "Random levels for syllable",
           "Random levels for subject & syllable")
plot_coefs(m2.p.0, m2.p.1, m2.p.2, m2.p.3, model.names=names, omit.coefs=NULL)
```

#### Tone 4 vs Not Tone 4

```{r}
# For tone 4
m4.p.0 <- model_predictors(dt4)
m4.p.1 <- model_predictors_subject(dt4)
m4.p.2 <- model_predictors_syllable(dt4)
m4.p.3 <- model_predictors_subject_syllable(dt4)
names <- c("Intercept only",
           "Random levels for subject",
           "Random levels for syllable",
           "Random levels for subject & syllable")
plot_coefs(m4.p.0, m4.p.1, m4.p.2, m4.p.3, model.names=names, omit.coefs=NULL)
```

#### Tone 1 vs Not Tone 1

```{r}
# For tone 1
m1.p.0 <- model_predictors(dt1)
m1.p.1 <- model_predictors_subject(dt1)
m1.p.2 <- model_predictors_syllable(dt1)
m1.p.3 <- model_predictors_subject_syllable(dt1)
names <- c("Intercept only",
           "Random levels for subject",
           "Random levels for syllable",
           "Random levels for subject & syllable")
plot_coefs(m1.p.0, m1.p.1, m1.p.2, m1.p.3, model.names=names, omit.coefs=NULL)
```

#### Tone 3 vs Not Tone 3

```{r}
# For tone 3
m3.p.0 <- model_predictors(dt3)
m3.p.1 <- model_predictors_subject(dt3)

#These two had the error: boundary (singular) fit: see ?isSingular 
#m3.p.2 <- model_predictors_syllable(dt3)
#m3.p.3 <- model_predictors_subject_syllable(dt3)

names <- c("Intercept only",
           "Random levels for subject")
plot_coefs(m3.p.0, m3.p.1, model.names=names, omit.coefs=NULL)
```

### Plotting probability curves

Looking at how the proability curve for each tone changes based on the predictor values. Feeds the set of predictor values used in the experiment into models for each tone and plotting the resulting probabilities. Note that multi-level models don't have the $predict()$ function.  

#### Tone 2 vs Not Tone 2

Tone 2 and Tone 4 have analogous shaped predictor curves, but tone 2 has more interaction effects between starting frequency and frequency shift. Given a lower starting frequency, less going up is needed for a stimuli to be perceived as Tone 2. The perception of tone 4 seems less influenced by starting frequency.

```{r}
pr2.1 <- ggpredict(m2.p.3, c("start.freq", "freq.shift")) %>% 
       plot() + labs(title = "Predicted probabilities of Tone 2")

pr2.2<- ggpredict(m2.p.3, c("freq.shift", "start.freq")) %>% plot() + 
  labs(title = " ") 

grid.arrange(pr2.1, pr2.2, nrow=1)

```

#### Tone 4 vs Not Tone 4

```{r}
pr4.1 <- ggpredict(m4.p.3, c("start.freq", "freq.shift")) %>% 
       plot() + labs(title = "Predicted probabilities of Tone 4")

pr4.2<- ggpredict(m4.p.3, c("freq.shift", "start.freq")) %>% plot() + 
  labs(title = " ") 

grid.arrange(pr4.1, pr4.2, nrow=1)
```

#### Tone 1 vs Not Tone 1

These are a bit strange. When the absolute value of freq.shift is high (e.g. 10, -10), the probability of Tone 1 should not be so high. 

```{r}
pr1.1 <- ggpredict(m1.p.3, c("start.freq", "freq.shift")) %>% 
       plot() + labs(title = "Predicted probabilities of Tone 1")

pr1.2<- ggpredict(m1.p.3, c("freq.shift", "start.freq")) %>% plot() + 
  labs(title = " ") 

grid.arrange(pr1.1, pr1.2, nrow=1)
```

Trying another model with start.freq and freq.shift as independent. This graph still doesn't make complete sense, but at least the curve with highest start frequency always has the highest probability. 

```{r}
m1.pi <- model_predictors_independent(dt1)
ggpredict(m1.pi, c("freq.shift", "start.freq")) %>% 
       plot() + labs(title = "Predicted probabilities of Tone 1")
```

#### Tone 3 vs Not Tone 3

This actually makes sense. Lower start frerquencies that still descend have a higher probability of getting classified as Tone 3. 

```{r}
pr3.1 <- ggpredict(m3.p.3, c("start.freq", "freq.shift")) %>% 
       plot() + labs(title = "Predicted probabilities of Tone 3")

pr3.2<- ggpredict(m3.p.3, c("freq.shift", "start.freq")) %>% plot() + 
  labs(title = " ") 

grid.arrange(pr3.1, pr3.2, nrow=1)
```

## Plotting Probabilities

The goal is to input some parameters for a stimuli and predict which tone it will get perceived as. Currently, I have a separate model for each tone, so making the overal prediction will involve looking at the probability for each tone and having some decision function.

To figure out what the decision function should be, let's look at what the probability for each tone is for each point in the study.

```{r}
library("analyze.stuff") #necessary for rowMaxs function

# Returns a df with all 49 data points in the study
get_stimuli_points <- function() {
  # Make a df with all the start.freq & end.freq combinations
  # Compute freq.shift
  points <- expand.grid(
    start.freq = seq(min(master$start.freq),
                     max(master$start.freq),
                     by = 2),
    end.freq = seq(min(master$end.freq),
                   max(master$end.freq),
                   by = 2)
  ) %>% mutate(freq.shift = end.freq - start.freq) 
  return(points)
}

# Takes a model for each of the tones and points to evaluate
# Compute probability for each tone at each point
# as well as max probability, put everything into a data frame
compute_probs_from_models <- function(mt1, mt2, mt3, mt4, points) {
  # Add probabilities for each tone
  points %>% mutate(t1probs = predict(mt1, points, type="response")) %>%
             mutate(t2probs = predict(mt2, points, type="response")) %>%
             mutate(t3probs = predict(mt3, points, type="response")) %>%
             mutate(t4probs = predict(mt4, points, type="response")) -> points
  
  # Make a new column of max probability
  max_probs <- select(points, c(t1probs, t2probs, t3probs, t4probs)) %>% rowMaxs()
  points <- cbind(points, max = max_probs)
  
  # Make a column that labels which tone has the max probability
  points %>% mutate(max.tone = ifelse(t1probs == max, "T1",
                               ifelse(t2probs == max, "T2",
                               ifelse(t3probs == max, "T3", "T4")))) -> points
  return(points)
}

# Takes probabilities for each tone, plots it on a grid of start/end frequencies
plot_grid_all <- function(probs) {
  probs %>% mutate(abs.freq.shift = abs(freq.shift)) -> probs
  ggplot(probs) + 
    xlab("Start frequency (ST)") + ylab("End Frequency (ST)") +
    scale_x_continuous(breaks = seq(-6, 6, by = 2)) +
    scale_y_continuous(breaks = seq(-6, 6, by = 2)) +
    geom_label(size = 2.5, mapping=aes(x=start.freq+0.35, y=end.freq+0.35, color=abs.freq.shift, 
                           label=format(round(t1probs,2), nsmall=2))) +
    geom_label(size = 2.5, mapping=aes(x=start.freq-0.35, y=end.freq+0.35, color=abs.freq.shift, 
                           label=format(round(t2probs,2), nsmall=2))) +
    geom_label(size = 2.5, mapping=aes(x=start.freq-0.35, y=end.freq-0.35, color=abs.freq.shift,
                           label=format(round(t3probs,2), nsmall=2))) +
    geom_label(size = 2.5, mapping=aes(x=start.freq+0.35, y=end.freq-0.35, color=abs.freq.shift,
                           label=format(round(t4probs,2), nsmall=2))) +
    #scale_color_viridis(option = "D") +
    labs(title="Probabilities for all tones", caption="T1 (top right), T2 (bottom right), T3 (bottom left), T4(top left). \nEach probability from a separate binary logit model for each tone, so they do not add up to 1", color="Absolute value \nof frequency \nshift (ST)") 
}

# Turn off scientific notation, so we can see the probabilities better
options(scipen=999)
options(digits = 6)

probs <- compute_probs_from_models(m1.p.0, m2.p.0, m3.p.0, m4.p.0, get_stimuli_points())
plot_grid_all(probs)
```

Replotting only the maximum probability at each point, colored by the tone. We can then impose a cutoff probability. For instance 0.6 or 0.7.

```{r}
plot_grid_max <- function(probs, my_title) {
  ggplot(probs) + 
    xlab("Start frequency (ST)") + ylab("End Frequency (ST)") +
    scale_x_continuous(breaks = seq(-6, 6, by = 2)) +
    scale_y_continuous(breaks = seq(-6, 6, by = 2)) +
    geom_label(mapping=aes(x=start.freq, y=end.freq, color=max.tone, 
                           label=format(round(max,2), nsmall=2))) +
    labs(title=my_title, color="Tone") 
}

p.max_probs <- plot_grid_max(probs, "Tone with max probability")

p.max_probs
```

Just for comparison, let's also plot the percentage choice of each tone for each stimuli point

```{r}
points2 <- get_stimuli_points()
points2.list <- split(points2, seq(nrow(points2)))

# Calculate percentages choices of each point
percents <- lapply(points2.list, function(elt) {
    start_freq<-elt[[1]]
    end_freq<-elt[[2]]
    freq_shift<-elt[[3]]
    total<-nrow(filter(master, start.freq == start_freq, end.freq == end_freq))
    t1_count<-nrow(filter(master, start.freq == start_freq, end.freq == end_freq, selected_tone=="T1"))
    t2_count<-nrow(filter(master, start.freq == start_freq, end.freq == end_freq, selected_tone=="T2"))
    t3_count<-nrow(filter(master, start.freq == start_freq, end.freq == end_freq, selected_tone=="T3"))
    t4_count<-nrow(filter(master, start.freq == start_freq, end.freq == end_freq, selected_tone=="T4"))
    return(list("start.freq"=start_freq, "end.freq"=end_freq, "freq.shift"= freq_shift,
                "t1.percent" = t1_count/total, "t2.percent" = t2_count/total,
                "t3.percent" = t3_count/total, "t4.percent" = t4_count/total))
})
# turn results back into a dataframe
percents <- do.call(rbind.data.frame, percents)
percents <- as_tibble(percents)

# Plot the percentages on a grid
plot_percents_all <- function(percents) {
  percents %>% mutate(abs.freq.shift = abs(freq.shift)) -> percents
  ggplot(percents) + 
    xlab("Start frequency (ST)") + ylab("End Frequency (ST)") +
    scale_x_continuous(breaks = seq(-6, 6, by = 2)) +
    scale_y_continuous(breaks = seq(-6, 6, by = 2)) +
    geom_label(size=2.5, mapping=aes(x=start.freq+0.35, y=end.freq+0.35, color=abs.freq.shift, 
                           label=format(round(t1.percent,2), nsmall=2))) +
    geom_label(size=2.5, mapping=aes(x=start.freq-0.35, y=end.freq+0.35, color=abs.freq.shift, 
                           label=format(round(t2.percent,2), nsmall=2))) +
    geom_label(size=2.5, mapping=aes(x=start.freq-0.35, y=end.freq-0.35, color=abs.freq.shift,
                           label=format(round(t3.percent,2), nsmall=2))) +
    geom_label(size=2.5, mapping=aes(x=start.freq+0.35, y=end.freq-0.35, color=abs.freq.shift,
                           label=format(round(t4.percent,2), nsmall=2))) +
   #scale_color_viridis(option = "D") +
    ggtitle(paste("Percent chosen for all tones"))
}
plot_percents_all(percents)
```

```{r}
# Find max percents and plot them
max_percents <- select(percents, c(t1.percent, t2.percent, t3.percent, t4.percent)) %>% rowMaxs()
percents <- cbind(percents, max = max_percents)
# Make a column that labels which tone has the max probability
percents %>% mutate(max.tone = ifelse(t1.percent == max, "T1",
                                      ifelse(t2.percent == max, "T2",
                                      ifelse(t3.percent == max, "T3", "T4")))) -> percents

p.max_percents <- plot_grid_max(percents, "Tone with max percentage chosen")

p.max_percents
```


